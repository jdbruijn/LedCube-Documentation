\hypertarget{BitOperations_8h}{}\section{Library\+Files/\+Bit\+Operations.h File Reference}
\label{BitOperations_8h}\index{Library\+Files/\+Bit\+Operations.\+h@{Library\+Files/\+Bit\+Operations.\+h}}


Several bit operations and manipulations.  


{\ttfamily \#include $<$xc.\+h$>$}\\*
{\ttfamily \#include $<$stdint.\+h$>$}\\*
{\ttfamily \#include $<$stdbool.\+h$>$}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\hypertarget{BitOperations_8h_a308d9dd2c0028ddb184b455bbd7865de}{}\#define \hyperlink{BitOperations_8h_a308d9dd2c0028ddb184b455bbd7865de}{C\+H\+A\+R\+\_\+\+B\+I\+T}~8\label{BitOperations_8h_a308d9dd2c0028ddb184b455bbd7865de}

\begin{DoxyCompactList}\small\item\em Number of bits in a byte. \end{DoxyCompactList}\item 
\#define \hyperlink{BitOperations_8h_a64a1040569b872756f843af5c35b5bd6}{bit\+Mask}(b)~(0x01 $<$$<$ (b))
\begin{DoxyCompactList}\small\item\em Create a bitmask. E.\+g. 0b00010000. \end{DoxyCompactList}\item 
\#define \hyperlink{BitOperations_8h_aac676cd1946cb1d66af5d75b1562734d}{bit\+Get}(b,  mask)  ~((b) \& (mask))
\begin{DoxyCompactList}\small\item\em Get the value of a bit or bits. \end{DoxyCompactList}\item 
\#define \hyperlink{BitOperations_8h_aaf863d398250b7ba8018173929b8dd77}{bit\+Set}(b,  mask)  ~((p) $\vert$= (mask))
\begin{DoxyCompactList}\small\item\em Set a bit or bits. \end{DoxyCompactList}\item 
\#define \hyperlink{BitOperations_8h_a3665f35a7a07abdd9a1cc6f227a7b43d}{bit\+Clear}(b,  mask)~((b) \&= ($\sim$(mask)))
\begin{DoxyCompactList}\small\item\em Clear a bit or bits. \end{DoxyCompactList}\item 
\#define \hyperlink{BitOperations_8h_af5eb041c8fac4d6e97483d8744c3bc62}{bit\+Flip}(b,  mask)~((b) $^\wedge$= (mask))
\begin{DoxyCompactList}\small\item\em Flip/toggle a bit or bits. \end{DoxyCompactList}\item 
\#define \hyperlink{BitOperations_8h_afb2f7bf3a70cef7ef4ab35fd7c56d852}{shift\+Left}(v,  p)~((v) $<$$<$= (p))
\begin{DoxyCompactList}\small\item\em Shift a variable left. \end{DoxyCompactList}\item 
\#define \hyperlink{BitOperations_8h_a02ffb69b10f0a6ad82a923b6858a3619}{shift\+Right}(v,  p)~((v) $>$$>$= (p))
\begin{DoxyCompactList}\small\item\em Shift a variable right. \end{DoxyCompactList}\item 
\#define \hyperlink{BitOperations_8h_aa62c107490f5fea40a7c869af83fc736}{shift\+Left\+M}(v,  p)~((v) $<$$<$ (p))
\begin{DoxyCompactList}\small\item\em Shift a variable left without changing the variable. \end{DoxyCompactList}\item 
\#define \hyperlink{BitOperations_8h_a37501aff9f5aed0238a7150651c5f952}{shift\+Right\+M}(v,  p)~((v) $<$$<$ (p))
\begin{DoxyCompactList}\small\item\em Shift a variable right without changing the variable. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{BitOperations_8h_ab7b317748b9d8e08812603975b2ad3fc}{is\+Positive} (int32\+\_\+t const \+\_\+v)
\begin{DoxyCompactList}\small\item\em Compute the sign of an integer. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8h_a5a16a55c4150b94d46a15bb4bdb16ab8}{have\+Opposite\+Signs} (int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)
\begin{DoxyCompactList}\small\item\em Detect if two integers have opposite signs. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{BitOperations_8h_a2a80e0c1b11281eedafad0691563e986}{min} (int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)
\begin{DoxyCompactList}\small\item\em Compute the minimum of two integers without branching. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{BitOperations_8h_a98b24b67752cb7a65d0bf14efd403a72}{max} (int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)
\begin{DoxyCompactList}\small\item\em Compute the maximum of two integers without branching. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8h_a26c3096ce57c1349f70a845b55eda1d2}{is\+Power\+Of2} (int32\+\_\+t const \+\_\+v)
\begin{DoxyCompactList}\small\item\em Determining if an integer is a power of two. \end{DoxyCompactList}\item 
void \hyperlink{BitOperations_8h_a4859424c19f3385795a4d3481153e41e}{modify\+Bits} (uint32\+\_\+t $\ast$\+\_\+v, uint32\+\_\+t const \+\_\+mask, bool const \+\_\+f)
\begin{DoxyCompactList}\small\item\em Conditionally set or clear bits without branching. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{BitOperations_8h_ac10caf47473a5d1c6b3cfd6808d61d9e}{merge\+Bits} (uint32\+\_\+t const \+\_\+x, uint32\+\_\+t const \+\_\+y, uint32\+\_\+t const \+\_\+mask)
\begin{DoxyCompactList}\small\item\em Merge bits from two values according to a mask. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{BitOperations_8h_a37bec38f51814420e4e81f8aed5f7bac}{n\+Bits\+Set} (int32\+\_\+t const \+\_\+v)
\begin{DoxyCompactList}\small\item\em Counting bits set. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8h_a52bc2e61d1421227989ecefb66cf51b1}{is\+Even} (uint32\+\_\+t const \+\_\+v)
\begin{DoxyCompactList}\small\item\em Compute parity of word with a multiply. \end{DoxyCompactList}\item 
void \hyperlink{BitOperations_8h_a0d25828bba771d7dc9a8e4bfd15d77c0}{reverse\+Bit\+Order} (uint32\+\_\+t $\ast$\+\_\+v)
\begin{DoxyCompactList}\small\item\em Reverse an N-\/bit quantity in parallel in 5 $\ast$ lg(\+N) operations. Now set to reverse the bit order of an 32 bit unsigned integer. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{BitOperations_8h_afda0074f3c08ef6c9f6c9a481dafd7c6}{round\+Up\+To\+Power\+Of2} (uint32\+\_\+t const \+\_\+v)
\begin{DoxyCompactList}\small\item\em Round up to the next highest power of two by float casting. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Several bit operations and manipulations. 

\begin{DoxyNote}{Note}
The macros and functions below are based on Sean Eron Anderson\textquotesingle{}s Bit Twiddling Hacks. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\href{https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign}{\tt https\+://graphics.\+stanford.\+edu/$\sim$seander/bithacks.\+html\#\+Copy\+Integer\+Sign} 

\href{https://github.com/gibsjose/BitHacks/blob/master/BitHacks.md#compute-the-sign-of-an-integer}{\tt https\+://github.\+com/gibsjose/\+Bit\+Hacks/blob/master/\+Bit\+Hacks.\+md\#compute-\/the-\/sign-\/of-\/an-\/integer} 
\end{DoxySeeAlso}


\subsection{Macro Definition Documentation}
\hypertarget{BitOperations_8h_a3665f35a7a07abdd9a1cc6f227a7b43d}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!bit\+Clear@{bit\+Clear}}
\index{bit\+Clear@{bit\+Clear}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{bit\+Clear}]{\setlength{\rightskip}{0pt plus 5cm}\#define bit\+Clear(
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{mask}
\end{DoxyParamCaption}
)~((b) \&= ($\sim$(mask)))}\label{BitOperations_8h_a3665f35a7a07abdd9a1cc6f227a7b43d}


Clear a bit or bits. 

\begin{DoxyNote}{Note}
This changes the variable! 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em b} & The variable to clear the bit(s) in. \\
\hline
{\em mask} & The mask for clearing the bit(s). \\
\hline
\end{DoxyParams}
\hypertarget{BitOperations_8h_af5eb041c8fac4d6e97483d8744c3bc62}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!bit\+Flip@{bit\+Flip}}
\index{bit\+Flip@{bit\+Flip}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{bit\+Flip}]{\setlength{\rightskip}{0pt plus 5cm}\#define bit\+Flip(
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{mask}
\end{DoxyParamCaption}
)~((b) $^\wedge$= (mask))}\label{BitOperations_8h_af5eb041c8fac4d6e97483d8744c3bc62}


Flip/toggle a bit or bits. 

\begin{DoxyNote}{Note}
This changes the variable! 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em b} & The variable to flip the bit(s) in. \\
\hline
{\em mask} & The mask for flipping the bit(s). \\
\hline
\end{DoxyParams}
\hypertarget{BitOperations_8h_aac676cd1946cb1d66af5d75b1562734d}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!bit\+Get@{bit\+Get}}
\index{bit\+Get@{bit\+Get}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{bit\+Get}]{\setlength{\rightskip}{0pt plus 5cm}\#define bit\+Get(
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{mask}
\end{DoxyParamCaption}
)~((b) \& (mask))}\label{BitOperations_8h_aac676cd1946cb1d66af5d75b1562734d}


Get the value of a bit or bits. 


\begin{DoxyParams}{Parameters}
{\em b} & The variable to get the bit(s) from. \\
\hline
{\em mask} & The mask for getting the bit(s). \\
\hline
\end{DoxyParams}
\hypertarget{BitOperations_8h_a64a1040569b872756f843af5c35b5bd6}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!bit\+Mask@{bit\+Mask}}
\index{bit\+Mask@{bit\+Mask}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{bit\+Mask}]{\setlength{\rightskip}{0pt plus 5cm}\#define bit\+Mask(
\begin{DoxyParamCaption}
\item[{}]{b}
\end{DoxyParamCaption}
)~(0x01 $<$$<$ (b))}\label{BitOperations_8h_a64a1040569b872756f843af5c35b5bd6}


Create a bitmask. E.\+g. 0b00010000. 


\begin{DoxyParams}{Parameters}
{\em b} & The number of the bit to create the mask for (0-\/64). \\
\hline
\end{DoxyParams}
\hypertarget{BitOperations_8h_aaf863d398250b7ba8018173929b8dd77}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!bit\+Set@{bit\+Set}}
\index{bit\+Set@{bit\+Set}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{bit\+Set}]{\setlength{\rightskip}{0pt plus 5cm}\#define bit\+Set(
\begin{DoxyParamCaption}
\item[{}]{b, }
\item[{}]{mask}
\end{DoxyParamCaption}
)~((p) $\vert$= (mask))}\label{BitOperations_8h_aaf863d398250b7ba8018173929b8dd77}


Set a bit or bits. 

\begin{DoxyNote}{Note}
This changes the variable! 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em b} & The variable to set the bit(s) in. \\
\hline
{\em mask} & The mask for setting the bit(s). \\
\hline
\end{DoxyParams}
\hypertarget{BitOperations_8h_afb2f7bf3a70cef7ef4ab35fd7c56d852}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!shift\+Left@{shift\+Left}}
\index{shift\+Left@{shift\+Left}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{shift\+Left}]{\setlength{\rightskip}{0pt plus 5cm}\#define shift\+Left(
\begin{DoxyParamCaption}
\item[{}]{v, }
\item[{}]{p}
\end{DoxyParamCaption}
)~((v) $<$$<$= (p))}\label{BitOperations_8h_afb2f7bf3a70cef7ef4ab35fd7c56d852}


Shift a variable left. 

\begin{DoxyNote}{Note}
This changes the variable! 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em v} & The variable to shift left. \\
\hline
{\em p} & Number of positions to shift the variable left. \\
\hline
\end{DoxyParams}
\hypertarget{BitOperations_8h_aa62c107490f5fea40a7c869af83fc736}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!shift\+Left\+M@{shift\+Left\+M}}
\index{shift\+Left\+M@{shift\+Left\+M}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{shift\+Left\+M}]{\setlength{\rightskip}{0pt plus 5cm}\#define shift\+Left\+M(
\begin{DoxyParamCaption}
\item[{}]{v, }
\item[{}]{p}
\end{DoxyParamCaption}
)~((v) $<$$<$ (p))}\label{BitOperations_8h_aa62c107490f5fea40a7c869af83fc736}


Shift a variable left without changing the variable. 

\begin{DoxyNote}{Note}
This does not change the variable. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em v} & The variable to shift left. \\
\hline
{\em p} & Number of positions to shift left. \\
\hline
\end{DoxyParams}
\hypertarget{BitOperations_8h_a02ffb69b10f0a6ad82a923b6858a3619}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!shift\+Right@{shift\+Right}}
\index{shift\+Right@{shift\+Right}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{shift\+Right}]{\setlength{\rightskip}{0pt plus 5cm}\#define shift\+Right(
\begin{DoxyParamCaption}
\item[{}]{v, }
\item[{}]{p}
\end{DoxyParamCaption}
)~((v) $>$$>$= (p))}\label{BitOperations_8h_a02ffb69b10f0a6ad82a923b6858a3619}


Shift a variable right. 

\begin{DoxyNote}{Note}
This changes the variable! 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em v} & The variable to shift right. \\
\hline
{\em p} & Number of positions to shift the variable right. \\
\hline
\end{DoxyParams}
\hypertarget{BitOperations_8h_a37501aff9f5aed0238a7150651c5f952}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!shift\+Right\+M@{shift\+Right\+M}}
\index{shift\+Right\+M@{shift\+Right\+M}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{shift\+Right\+M}]{\setlength{\rightskip}{0pt plus 5cm}\#define shift\+Right\+M(
\begin{DoxyParamCaption}
\item[{}]{v, }
\item[{}]{p}
\end{DoxyParamCaption}
)~((v) $<$$<$ (p))}\label{BitOperations_8h_a37501aff9f5aed0238a7150651c5f952}


Shift a variable right without changing the variable. 

\begin{DoxyNote}{Note}
This does not change the variable. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em v} & The variable to shift right. \\
\hline
{\em p} & Number of positions to shift right. \\
\hline
\end{DoxyParams}


\subsection{Function Documentation}
\hypertarget{BitOperations_8h_a5a16a55c4150b94d46a15bb4bdb16ab8}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!have\+Opposite\+Signs@{have\+Opposite\+Signs}}
\index{have\+Opposite\+Signs@{have\+Opposite\+Signs}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{have\+Opposite\+Signs(int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)}]{\setlength{\rightskip}{0pt plus 5cm}bool have\+Opposite\+Signs (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t const}]{\+\_\+x, }
\item[{int32\+\_\+t const}]{\+\_\+y}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_a5a16a55c4150b94d46a15bb4bdb16ab8}


Detect if two integers have opposite signs. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+x} & First variable of which the signs need to be compared. \\
\hline
{\em \+\_\+y} & Second variable of which the signs need to be compared. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if the variables have opposite signs, false else. 
\end{DoxyReturn}
\hypertarget{BitOperations_8h_a52bc2e61d1421227989ecefb66cf51b1}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!is\+Even@{is\+Even}}
\index{is\+Even@{is\+Even}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{is\+Even(uint32\+\_\+t const \+\_\+v)}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Even (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t const}]{\+\_\+v}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_a52bc2e61d1421227989ecefb66cf51b1}


Compute parity of word with a multiply. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+v} & Variable of which to compute the parity. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if \+\_\+v is odd, false else. 
\end{DoxyReturn}
\hypertarget{BitOperations_8h_ab7b317748b9d8e08812603975b2ad3fc}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!is\+Positive@{is\+Positive}}
\index{is\+Positive@{is\+Positive}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{is\+Positive(int32\+\_\+t const \+\_\+v)}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Positive (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t const}]{\+\_\+v}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_ab7b317748b9d8e08812603975b2ad3fc}


Compute the sign of an integer. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+v} & Variable of which to compute the sign. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if the variable is positive, false else. 
\end{DoxyReturn}
\hypertarget{BitOperations_8h_a26c3096ce57c1349f70a845b55eda1d2}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!is\+Power\+Of2@{is\+Power\+Of2}}
\index{is\+Power\+Of2@{is\+Power\+Of2}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{is\+Power\+Of2(int32\+\_\+t const \+\_\+v)}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Power\+Of2 (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t const}]{\+\_\+v}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_a26c3096ce57c1349f70a845b55eda1d2}


Determining if an integer is a power of two. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+v,variable} & of which to check if it is a power of two. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if \+\_\+v is a power of to, false else. 
\end{DoxyReturn}
\hypertarget{BitOperations_8h_a98b24b67752cb7a65d0bf14efd403a72}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!max@{max}}
\index{max@{max}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{max(int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t max (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t const}]{\+\_\+x, }
\item[{int32\+\_\+t const}]{\+\_\+y}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_a98b24b67752cb7a65d0bf14efd403a72}


Compute the maximum of two integers without branching. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+x} & First variable of which the maximum needs to be found. \\
\hline
{\em \+\_\+y} & Second variable of which the maximum needs to be found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int32\+\_\+t The maximum value, \+\_\+x or \+\_\+y. 
\end{DoxyReturn}
\hypertarget{BitOperations_8h_ac10caf47473a5d1c6b3cfd6808d61d9e}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!merge\+Bits@{merge\+Bits}}
\index{merge\+Bits@{merge\+Bits}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{merge\+Bits(uint32\+\_\+t const \+\_\+x, uint32\+\_\+t const \+\_\+y, uint32\+\_\+t const \+\_\+mask)}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t merge\+Bits (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t const}]{\+\_\+x, }
\item[{uint32\+\_\+t const}]{\+\_\+y, }
\item[{uint32\+\_\+t const}]{\+\_\+mask}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_ac10caf47473a5d1c6b3cfd6808d61d9e}


Merge bits from two values according to a mask. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+x} & Variable to merge in non-\/masked bits. \\
\hline
{\em \+\_\+y} & Variable to merge in masked bits. \\
\hline
{\em \+\_\+mask} & Bit mask for setting or clearing bits. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint32\+\_\+t Result of the merged variables \+\_\+x and \+\_\+y. 
\end{DoxyReturn}
\hypertarget{BitOperations_8h_a2a80e0c1b11281eedafad0691563e986}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!min@{min}}
\index{min@{min}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{min(int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t min (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t const}]{\+\_\+x, }
\item[{int32\+\_\+t const}]{\+\_\+y}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_a2a80e0c1b11281eedafad0691563e986}


Compute the minimum of two integers without branching. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+x} & First variable of which the minimum needs to be found. \\
\hline
{\em \+\_\+y} & Second variable of which the minimum needs to be found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int32\+\_\+t The minimum value, \+\_\+x or \+\_\+y. 
\end{DoxyReturn}
\hypertarget{BitOperations_8h_a4859424c19f3385795a4d3481153e41e}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!modify\+Bits@{modify\+Bits}}
\index{modify\+Bits@{modify\+Bits}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{modify\+Bits(uint32\+\_\+t $\ast$\+\_\+v, uint32\+\_\+t const \+\_\+mask, bool const \+\_\+f)}]{\setlength{\rightskip}{0pt plus 5cm}void modify\+Bits (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t $\ast$}]{\+\_\+v, }
\item[{uint32\+\_\+t const}]{\+\_\+mask, }
\item[{bool const}]{\+\_\+f}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_a4859424c19f3385795a4d3481153e41e}


Conditionally set or clear bits without branching. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+v} & Pointer to the variable of which to set or clear bits. \\
\hline
{\em \+\_\+mask} & Bit mask for setting or clearing bits. \\
\hline
{\em \+\_\+f} & Flag whether the bits needs to be set or cleared (1 or 0). \\
\hline
\end{DoxyParams}
\hypertarget{BitOperations_8h_a37bec38f51814420e4e81f8aed5f7bac}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!n\+Bits\+Set@{n\+Bits\+Set}}
\index{n\+Bits\+Set@{n\+Bits\+Set}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{n\+Bits\+Set(int32\+\_\+t const \+\_\+v)}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t n\+Bits\+Set (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t const}]{\+\_\+v}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_a37bec38f51814420e4e81f8aed5f7bac}


Counting bits set. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+v} & Variable of which to check how much bits are set. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint8\+\_\+t Number of bits set in \+\_\+v. 
\end{DoxyReturn}
\hypertarget{BitOperations_8h_a0d25828bba771d7dc9a8e4bfd15d77c0}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!reverse\+Bit\+Order@{reverse\+Bit\+Order}}
\index{reverse\+Bit\+Order@{reverse\+Bit\+Order}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{reverse\+Bit\+Order(uint32\+\_\+t $\ast$\+\_\+v)}]{\setlength{\rightskip}{0pt plus 5cm}void reverse\+Bit\+Order (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t $\ast$}]{\+\_\+v}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_a0d25828bba771d7dc9a8e4bfd15d77c0}


Reverse an N-\/bit quantity in parallel in 5 $\ast$ lg(\+N) operations. Now set to reverse the bit order of an 32 bit unsigned integer. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+v} & Pointer to the variable of which the bit order needs to be reversed. \\
\hline
\end{DoxyParams}
\hypertarget{BitOperations_8h_afda0074f3c08ef6c9f6c9a481dafd7c6}{}\index{Bit\+Operations.\+h@{Bit\+Operations.\+h}!round\+Up\+To\+Power\+Of2@{round\+Up\+To\+Power\+Of2}}
\index{round\+Up\+To\+Power\+Of2@{round\+Up\+To\+Power\+Of2}!Bit\+Operations.\+h@{Bit\+Operations.\+h}}
\subsubsection[{round\+Up\+To\+Power\+Of2(uint32\+\_\+t const \+\_\+v)}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t round\+Up\+To\+Power\+Of2 (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t const}]{\+\_\+v}
\end{DoxyParamCaption}
)}\label{BitOperations_8h_afda0074f3c08ef6c9f6c9a481dafd7c6}


Round up to the next highest power of two by float casting. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+v} & Pointer to the variable of which needs to be round up to the next power of two. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint16\+\_\+t The next power of two. 
\end{DoxyReturn}
